# uxml (micro-xml) parses xml in an evented way, much like a SAX parser.

STATE_START = 0 # expect opentag ('<') or text
STATE_TNAME = 1 # expect tag name followed by space or closetag.
STATE_ATTRS = 2 # expect key="value" pairs or closetag ('>')

ATTR_RE = /^\s*(.+)\s*=\s*('(?:[^']*)'|"(?:[^"]*)")/

# Given a node stream of data, consume bytes and callback on handler as elements are encountered.
# Handler is an object of callback functions.
# May throw an error synchronously. Watch out.
@parseStream = (stream, handler) ->

  throw new Error("Parse handler requires 'emit' method") if not handler?.emit?
  throw new Error("Stream should exist and be readable") if not stream? or not stream.readable

  _state  = STATE_START
  _buffer = '' # whatever remains to be parsed
  _attrs  = {} # accumulation of attributes

  # Streams should support utf8 only.
  stream.setEncoding('utf8')

  # When data is received, parse it.
  stream.on 'data', (data) ->

    throw new Error("Stream data should have been a unicode string") unless typeof data is 'string'

    _buffer += data

    # Parse as much as possible
    loop
      switch _state
        when STATE_START
          if ltPos=_buffer.search('<') is -1
            return
          else if ltPos > 0
            handler.emit('text', _buffer[...ltPos])
            _buffer = _buffer[ltPos+1...]
            _state  = STATE_ATTRS
            continue
          else
            _buffer = _buffer[1...]
            _state = STATE_ATTRS
            continue
        when STATE_ATTRS
          while res=_parseAttribute(_buffer, _attrs) isnt undefined
            _buffer = res
          if gtMatch=_buffer.match(/^\s*>/)
            _buffer = _buffer[gtMatch[0].length...]
            _state  = STATE_START
            continue
          else
            return

  # When stream ends or errors, pass the event along
  stream.on 'end', -> handler.emit('end')
  stream.on 'error', (error) -> handler.emit('error', error)

# Assuming that text is the beginning of an attribute (e.g. blahblah="somevalue")
# Try to parse out an attribute and...
# (1) If successful, add attribute to attrs and return the remaining text
# (2) If attribute isn't complete (e.g. blahblah="some ), return undefined
# (3) If text is malformed (e.g. blahblah=> ), throw an error
_parseAttribute = (text, attrs) ->

  match = text.match ATTR_RE

  if match?
    name = match[1]
    value = match[2]
    # Error checks for quick fail
    # I wonder if you would go about proving correctness...
    if name.search(/[= ]/) isnt -1
      throw new Error "Parser error: expected attribute but got '#{text}'"
    attrs[name] = value
    return text[match[0].length...]

  else
    return undefined
